

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="景岳的博客">
  <meta name="author" content="Jing Yue">
  <meta name="keywords" content="博客 景岳">
  <title>Neo4j 学习 - 景岳</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>景岳</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-12 11:16" pubdate>
        2020年10月12日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      129
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Neo4j 学习</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h1><h2 id="第一章：介绍"><a href="#第一章：介绍" class="headerlink" title="第一章：介绍"></a>第一章：介绍</h2><h3 id="Neo4j是什么"><a href="#Neo4j是什么" class="headerlink" title="Neo4j是什么"></a>Neo4j是什么</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Neo4j">Neo4j</a>是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F">嵌入式</a>的、基于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98">磁盘</a>的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。Neo4j也可以被看作是一个高性能的图引擎，该引擎具有成熟数据库的所有特性。程序员工作在一个面向对象的、灵活的网络结构下而不是严格、静态的表中——但是他们可以享受到具备完全的事务特性、企业级的数据库的所有好处。</p>
<h3 id="Neo4j的特点"><a href="#Neo4j的特点" class="headerlink" title="Neo4j的特点"></a>Neo4j的特点</h3><ul>
<li>SQL 就像简单的查询语言 Neo4j CQL</li>
<li>它遵循属性图数据模型</li>
<li>它通过使用Apache Lucence支持索引</li>
<li>它支持 UNIQUE 约束</li>
<li>它它包含一个用于执行 CQL 命令的 UI：Neo4j 数据浏览器</li>
<li>它支持完整的 ACID（原子性，一致性，隔离性和持久性）规则</li>
<li>它采用原生图形库与本地 GPE（图形处理引擎）</li>
<li>它支持查询的数据导出到 JSON 和 XLS 格式</li>
<li>它提供了 REST API，可以被任何编程语言（如Java，Spring，Scala等）访问</li>
<li>它提供了可以通过任何 UI MVC 框架（如Node JS）访问的 Java 脚本</li>
<li>它支持两种 Java AP I：Cypher API 和 Native Java API 来开发 Java 应用程序</li>
</ul>
<h3 id="Neo4j的优点"><a href="#Neo4j的优点" class="headerlink" title="Neo4j的优点"></a>Neo4j的优点</h3><ul>
<li>它很容易表示连接的数据</li>
<li>检索/遍历/导航更多的连接数据是非常容易和快速的</li>
<li>它非常容易地表示半结构化数据</li>
<li>Neo4j CQL查询语言命令是人性化的可读格式，非常容易学习</li>
<li>它使用简单而强大的数据模型</li>
<li>它不需要复杂的连接来检索连接的/相关的数据，因为它很容易检索它的相邻节点或关系细节没有连接或索引</li>
</ul>
<h2 id="第二章：安装"><a href="#第二章：安装" class="headerlink" title="第二章：安装"></a>第二章：安装</h2><h3 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h3><p>  Centos 7.4</p>
<p>   neo4j-community-3.4.1.tar.gz</p>
<h3 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h3><p>下载地址 <a target="_blank" rel="noopener" href="https://neo4j.com/download/other-releases/">https://neo4j.com/download/other-releases/</a></p>
<p>下载</p>
<pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://neo<span class="hljs-number">4</span>j.com/artifact.php?name=neo<span class="hljs-number">4</span>j-community-<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>-unix.tar.gz</code></pre>

<p>解压</p>
<pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf neo<span class="hljs-number">4</span>j-community-<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.tar.gz</code></pre>

<p>docker 下载</p>
<pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull neo<span class="hljs-number">4</span>j</code></pre>

<p>Neo4j映像的文档可以在<a target="_blank" rel="noopener" href="https://neo4j.com/docs/operations-manual/current/deployment/single-instance/docker/">这里</a>找到。</p>
<p>可以像这样启动 Neo4j 容器：</p>
<pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> \
    <span class="hljs-attribute">--publish</span>=7474:7474 <span class="hljs-attribute">--publish</span>=7687:7687 \
    <span class="hljs-attribute">--volume</span>=<span class="hljs-variable">$HOME</span>/neo4j/data:/data \
    <span class="hljs-attribute">--volume</span>=<span class="hljs-variable">$HOME</span>/neo4j/logs:/logs \
    neo4j:latest</code></pre>

<p>要启动 Neo4j 企业版容器，您可以运行：</p>
<pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> \
    <span class="hljs-attribute">--publish</span>=7474:7474 <span class="hljs-attribute">--publish</span>=7687:7687 \
    <span class="hljs-attribute">--env</span>=NEO4J_ACCEPT_LICENSE_AGREEMENT=yes \
    <span class="hljs-attribute">--volume</span>=<span class="hljs-variable">$HOME</span>/neo4j/data:/data \
    <span class="hljs-attribute">--volume</span>=<span class="hljs-variable">$HOME</span>/neo4j/logs:/logs \
    neo4j:enterprise</code></pre>

<p>挂载 <code>/data</code>and <code>/logs</code>文件夹是可选的，但这意味着在关闭和重新打开 Neo4j 容器之间可以保留数据。</p>
<h3 id="3-开启远程访问"><a href="#3-开启远程访问" class="headerlink" title="3.开启远程访问"></a>3.开启远程访问</h3><p><strong>一、对于3.0以前的版本</strong></p>
<p>在安装目录的 $NEO4J_HOME/conf/neo4j.conf 文件内，找到下面一行，将注释#号去掉就可以了 <code>#dbms.connector.https.address=localhost:7473</code> 改为 <code>dbms.connector.https.address=0.0.0.0:7473</code> 这样，远程其他电脑可以用本机的IP或者域名后面跟上7474 端口就能打开web界面了 如： https://:7473</p>
<p>当然，你的操作系统的防火墙也要确保开放了7474端口才行，防火墙怎样开放请自行针对自己的操作系统查找文档</p>
<p><strong>二、对于3.1及以后的版本</strong></p>
<p>在安装目录的 $NEO4J_HOME/conf/neo4j.conf 文件内，找到下面一行，将注释#号去掉就可以了 <code>dbms.connectors.default_listen_address=0.0.0.0</code></p>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>在bin目录下，执行命令：./neo4j start启动，其他命令 { console | start | stop | restart | status }</p>
<p>访问<code>http://IP地址:7474/</code>, 出现下图即代表安装成功，顶部的$输入框用来执行下面的CQL语句。</p>
<h2 id="第三章：CQL"><a href="#第三章：CQL" class="headerlink" title="第三章：CQL"></a>第三章：CQL</h2><h3 id="1-CQL简介"><a href="#1-CQL简介" class="headerlink" title="1.CQL简介"></a>1.CQL简介</h3><p>CQL代表Cypher查询语言。 像Oracle数据库具有查询语言SQL，Neo4j具有CQL作为查询语言。</p>
<p><strong>Neo4j CQL -</strong></p>
<ul>
<li>它是Neo4j图形数据库的查询语言。</li>
<li>它是一种声明性模式匹配语言</li>
<li>它遵循SQL语法。</li>
<li>它的语法是非常简单且人性化、可读的格式。</li>
</ul>
<p><strong>如Oracle SQL -</strong></p>
<ul>
<li>Neo4j CQL 已命令来执行数据库操作。</li>
<li>Neo4j CQL 支持多个子句像在哪里，顺序等，以非常简单的方式编写非常复杂的查询。</li>
<li>NNeo4j CQL 支持一些功能，如字符串，Aggregation.In 加入他们，它还支持一些关系功能。</li>
</ul>
<h3 id="2-Neo4j-CQL命令-条款"><a href="#2-Neo4j-CQL命令-条款" class="headerlink" title="2.Neo4j CQL命令/条款"></a>2.Neo4j CQL命令/条款</h3><p>常用的Neo4j CQL命令/条款如下：</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">CQL命令/条</th>
<th align="left">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">CREATE 创建</td>
<td align="left">创建节点，关系和属性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">MATCH 匹配</td>
<td align="left">检索有关节点，关系和属性数据</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">RETURN 返回</td>
<td align="left">返回查询结果</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">WHERE 哪里</td>
<td align="left">提供条件过滤检索数据</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">DELETE 删除</td>
<td align="left">删除节点和关系</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">REMOVE 移除</td>
<td align="left">删除节点和关系的属性</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">ORDER BY以…排序</td>
<td align="left">排序检索数据</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">SET 组</td>
<td align="left">添加或更新标签</td>
</tr>
</tbody></table>
<h3 id="3-Neo4j-CQL-函数"><a href="#3-Neo4j-CQL-函数" class="headerlink" title="3.Neo4j CQL 函数"></a>3.Neo4j CQL 函数</h3><p>以下是常用的Neo4j CQL函数：</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">定制列表功能</th>
<th align="left">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">String 字符串</td>
<td align="left">它们用于使用String字面量。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">Aggregation 聚合</td>
<td align="left">它们用于对CQL查询结果执行一些聚合操作。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">Relationship 关系</td>
<td align="left">他们用于获取关系的细节，如startnode，endnode等。</td>
</tr>
</tbody></table>
<p>我们将在后面的章节中详细讨论所有Neo4j CQL命令，子句和函数语法，用法和示例。</p>
<h3 id="4-Neo4j-CQL数据类型"><a href="#4-Neo4j-CQL数据类型" class="headerlink" title="4.Neo4j CQL数据类型"></a>4.Neo4j CQL数据类型</h3><p>这些数据类型与Java语言类似。 它们用于定义节点或关系的属性</p>
<p>Neo4j CQL支持以下数据类型：</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">CQL数据类型</th>
<th align="left">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="left">boolean</td>
<td align="left">用于表示布尔文字：true，false。</td>
</tr>
<tr>
<td align="center">2.</td>
<td align="left">byte</td>
<td align="left">用于表示8位整数。</td>
</tr>
<tr>
<td align="center">3.</td>
<td align="left">short</td>
<td align="left">用于表示16位整数。</td>
</tr>
<tr>
<td align="center">4.</td>
<td align="left">int</td>
<td align="left">用于表示32位整数。</td>
</tr>
<tr>
<td align="center">5.</td>
<td align="left">long</td>
<td align="left">用于表示64位整数。</td>
</tr>
<tr>
<td align="center">6.</td>
<td align="left">float</td>
<td align="left">I用于表示32位浮点数。</td>
</tr>
<tr>
<td align="center">7.</td>
<td align="left">double</td>
<td align="left">用于表示64位浮点数。</td>
</tr>
<tr>
<td align="center">8.</td>
<td align="left">char</td>
<td align="left">用于表示16位字符。</td>
</tr>
<tr>
<td align="center">9.</td>
<td align="left">String</td>
<td align="left">用于表示字符串。</td>
</tr>
</tbody></table>
<h2 id="第四章：命令"><a href="#第四章：命令" class="headerlink" title="第四章：命令"></a>第四章：命令</h2><h3 id="1-CREATE创建"><a href="#1-CREATE创建" class="headerlink" title="1.CREATE创建"></a>1.CREATE创建</h3><p><strong>Neo4j CQL创建一个没有属性的节点</strong></p>
<pre><code class="hljs elixir">CREATE (&lt;node-name&gt;<span class="hljs-symbol">:&lt;label-name&gt;</span>)</code></pre>

<p>语法说明</p>
<p>规范说法是节点标签名称，其实相当于Mysql数据库中的表名，而是节点名称，其实代指创建的此行数据。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs lisp">CREATE (<span class="hljs-name">emp</span><span class="hljs-symbol">:Employee</span>)</code></pre>

<p>或者</p>
<pre><code class="hljs gauss"><span class="hljs-keyword">CREATE</span> (:Employee)</code></pre>

<p><strong>Neo4j CQL创建具有属性的节点</strong></p>
<p>Neo4j CQL“CREATE”命令用于创建带有属性的节点。 它创建一个具有一些属性（键值对）的节点来存储数据。</p>
<pre><code class="hljs elixir">CREATE (
   &lt;node-name&gt;<span class="hljs-symbol">:&lt;label-name&gt;</span>
   &#123;    
      &lt;key&gt;<span class="hljs-symbol">:&lt;Value&gt;</span>
      ........
      &lt;n-key&gt;<span class="hljs-symbol">:&lt;n-Value&gt;</span>
   &#125;
)<span class="hljs-number">1234567</span></code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-tag">CREATE</span> (<span class="hljs-selector-tag">dept</span><span class="hljs-selector-pseudo">:Dept</span> &#123; <span class="hljs-attribute">deptno</span>:<span class="hljs-number">10</span>,dname:<span class="hljs-string">&quot;Accounting&quot;</span>,location:<span class="hljs-string">&quot;Hyderabad&quot;</span> &#125;)</code></pre>

<p><strong>创建多个标签到节点</strong></p>
<p>语法：</p>
<pre><code class="hljs elixir">CREATE (&lt;node-name&gt;<span class="hljs-symbol">:&lt;label-name1&gt;</span><span class="hljs-symbol">:&lt;label-name2&gt;</span>.....<span class="hljs-symbol">:&lt;label-namen&gt;</span>)</code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs lisp">CREATE (<span class="hljs-name">m</span><span class="hljs-symbol">:Movie</span><span class="hljs-symbol">:Cinema</span><span class="hljs-symbol">:Film</span><span class="hljs-symbol">:Picture</span>)</code></pre>

<h3 id="2-MATCH查询"><a href="#2-MATCH查询" class="headerlink" title="2.MATCH查询"></a>2.MATCH查询</h3><p>Neo4j CQL MATCH命令用于</p>
<ul>
<li>从数据库获取有关节点和属性的数据</li>
<li>从数据库获取有关节点，关系和属性的数据</li>
</ul>
<p>MATCH命令语法：</p>
<pre><code class="hljs elixir">MATCH 
(
   &lt;node-name&gt;<span class="hljs-symbol">:&lt;label-name&gt;</span>
)<span class="hljs-number">123</span></code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs lisp">MATCH (<span class="hljs-name">dept</span><span class="hljs-symbol">:Dept</span>)</code></pre>

<p>但是执行后会报错：</p>
<pre><code class="hljs sql">Neo.ClientError.Statement.SyntaxError: 
Query cannot conclude <span class="hljs-keyword">with</span> <span class="hljs-keyword">MATCH</span> 
(must be <span class="hljs-keyword">RETURN</span> <span class="hljs-keyword">or</span> an <span class="hljs-keyword">update</span> clause) (line <span class="hljs-number">1</span>, <span class="hljs-keyword">column</span> <span class="hljs-number">1</span> (<span class="hljs-keyword">offset</span>: <span class="hljs-number">0</span>))<span class="hljs-number">12</span></code></pre>

<p>如果你观察到错误消息，它告诉我们，我们可以使用MATCH命令与RETURN子句或UPDATA子句。</p>
<h3 id="3-RETURN返回"><a href="#3-RETURN返回" class="headerlink" title="3.RETURN返回"></a>3.RETURN返回</h3><p>Neo4j CQL RETURN子句用于 -</p>
<ul>
<li>检索节点的某些属性</li>
<li>检索节点的所有属性</li>
<li>检索节点和关联关系的某些属性</li>
<li>检索节点和关联关系的所有属性</li>
</ul>
<p>RETURN命令语法：</p>
<pre><code class="hljs fortran"><span class="hljs-keyword">RETURN</span> 
   &lt;node-<span class="hljs-keyword">name</span>&gt;<span class="hljs-number">.</span>&lt;property1-<span class="hljs-keyword">name</span>&gt;,
   <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span>
   &lt;node-<span class="hljs-keyword">name</span>&gt;<span class="hljs-number">.</span>&lt;propertyn-<span class="hljs-keyword">name</span>&gt;<span class="hljs-number">123</span></code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs lisp">MATCH (<span class="hljs-name">e</span><span class="hljs-symbol">:Employee</span>) RETURN e</code></pre>

<p>或</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">dept</span>: <span class="hljs-selector-tag">Dept</span>)
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">dept</span><span class="hljs-selector-class">.deptno</span>,<span class="hljs-selector-tag">dept</span><span class="hljs-selector-class">.dname</span>,<span class="hljs-selector-tag">dept</span><span class="hljs-selector-class">.location1</span></code></pre>

<h3 id="4-关系基础"><a href="#4-关系基础" class="headerlink" title="4.关系基础"></a>4.关系基础</h3><p>Neo4j图数据库遵循属性图模型来存储和管理其数据。</p>
<p>根据属性图模型，关系应该是定向的。 否则，Neo4j将抛出一个错误消息。</p>
<p>基于方向性，Neo4j关系被分为两种主要类型。</p>
<ul>
<li>单向关系</li>
<li>双向关系</li>
</ul>
<p><strong>使用新节点创建关系</strong></p>
<p><strong>示例</strong></p>
<pre><code class="hljs less"><span class="hljs-selector-tag">CREATE</span> (<span class="hljs-attribute">e</span>:Employee)<span class="hljs-selector-tag">-</span><span class="hljs-selector-attr">[r:DemoRelation]</span><span class="hljs-selector-tag">-</span>&gt;(<span class="hljs-attribute">c</span>:Employee)</code></pre>

<p>这句会创建节点e，节点c，以及e -&gt; c的关系r，这里需要注意方向，比如双向是</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">CREATE</span> (<span class="hljs-selector-tag">e</span><span class="hljs-selector-pseudo">:Employee)</span>&lt;<span class="hljs-selector-tag">-</span><span class="hljs-selector-attr">[r:DemoRelation]</span><span class="hljs-selector-tag">-</span>&gt;(<span class="hljs-selector-tag">c</span><span class="hljs-selector-pseudo">:Employee)</span></code></pre>

<p><strong>使用已知节点创建带属性的关系：</strong></p>
<pre><code class="hljs elixir">MATCH (&lt;node1-label-name&gt;<span class="hljs-symbol">:&lt;node1-name&gt;</span>),(&lt;node2-label-name&gt;<span class="hljs-symbol">:&lt;node2-name&gt;</span>)
CREATE  
    (&lt;node1-label-name&gt;)-[&lt;relationship-label-name&gt;<span class="hljs-symbol">:&lt;relationship-name&gt;</span>
    &#123;&lt;define-properties-list&gt;&#125;]-&gt;(&lt;node2-label-name&gt;)
RETURN &lt;relationship-label-name&gt;<span class="hljs-number">1234</span></code></pre>

<blockquote>
<p>还是一系列键值对</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code class="hljs less"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-attribute">cust</span>:Customer),(<span class="hljs-attribute">cc</span>:CreditCard) 
<span class="hljs-selector-tag">CREATE</span> (cust)<span class="hljs-selector-tag">-</span><span class="hljs-selector-attr">[r:DO_SHOPPING_WITH&#123;shopdate:&quot;12/12/2014&quot;,price:55000&#125;]</span><span class="hljs-selector-tag">-</span>&gt;(cc) 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">r12</span></code></pre>

<p><strong>检索关系节点的详细信息：</strong></p>
<pre><code class="hljs fsharp">MATCH 
(&lt;node1-label-name&gt;)-<span class="hljs-meta">[&lt;relationship-label-name&gt;:&lt;relationship-name&gt;]</span>-&gt;(&lt;node2-label-name&gt;)
RETURN &lt;relationship-label-name&gt;<span class="hljs-number">12</span></code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs less"><span class="hljs-selector-tag">MATCH</span> (cust)<span class="hljs-selector-tag">-</span><span class="hljs-selector-attr">[r:DO_SHOPPING_WITH]</span><span class="hljs-selector-tag">-</span>&gt;(cc) 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">cust</span>,<span class="hljs-selector-tag">cc1</span></code></pre>

<h3 id="5-WHERE子句"><a href="#5-WHERE子句" class="headerlink" title="5.WHERE子句"></a>5.WHERE子句</h3><p>像SQL一样，Neo4j CQL在CQL MATCH命令中提供了WHERE子句来过滤MATCH查询的结果。</p>
<p><strong>简单WHERE子句语法</strong></p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">WHERE</span> &lt;property-<span class="hljs-type">name</span>&gt; &lt;comparison-<span class="hljs-keyword">operator</span>&gt; &lt;<span class="hljs-keyword">value</span>&gt;</code></pre>

<p>语法说明：</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">语法元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">WHERE</td>
<td align="left">它是一个Neo4j CQL关键字。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">&lt;属性名称&gt;</td>
<td align="left">它是节点或关系的属性名称。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">&lt;比较运算符&gt;</td>
<td align="left">它是Neo4j CQL比较运算符之一。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">&lt;值&gt;</td>
<td align="left">它是一个字面值，如数字文字，字符串文字等。</td>
</tr>
</tbody></table>
<p><strong>Neo4j CQL中的比较运算符</strong></p>
<p>Neo4j 支持以下的比较运算符，在 Neo4j CQL WHERE 子句中使用来支持条件</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">布尔运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="left">=</td>
<td align="left">它是Neo4j CQL“等于”运算符。</td>
</tr>
<tr>
<td align="center">2.</td>
<td align="left">&lt;&gt;</td>
<td align="left">它是一个Neo4j CQL“不等于”运算符。</td>
</tr>
<tr>
<td align="center">3.</td>
<td align="left">&lt;</td>
<td align="left">它是一个Neo4j CQL“小于”运算符。</td>
</tr>
<tr>
<td align="center">4.</td>
<td align="left">&gt;</td>
<td align="left">它是一个Neo4j CQL“大于”运算符。</td>
</tr>
<tr>
<td align="center">5.</td>
<td align="left">&lt;=</td>
<td align="left">它是一个Neo4j CQL“小于或等于”运算符。</td>
</tr>
<tr>
<td align="center">6.</td>
<td align="left">=</td>
<td align="left">它是一个Neo4j CQL“大于或等于”运算符。</td>
</tr>
</tbody></table>
<p>我们可以使用布尔运算符在同一命令上放置多个条件。</p>
<p><strong>Neo4j CQL中的布尔运算符</strong></p>
<p>Neo4j支持以下布尔运算符在Neo4j CQL WHERE子句中使用以支持多个条件。</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">布尔运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">AND</td>
<td align="left">它是一个支持AND操作的Neo4j CQL关键字。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">OR</td>
<td align="left">它是一个Neo4j CQL关键字来支持OR操作。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">NOT</td>
<td align="left">它是一个Neo4j CQL关键字支持NOT操作。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">XOR</td>
<td align="left">它是一个支持XOR操作的Neo4j CQL关键字。</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<pre><code class="hljs pgsql">MATCH (emp:Employee) 
<span class="hljs-keyword">WHERE</span> emp.name = <span class="hljs-string">&#x27;Abc&#x27;</span> <span class="hljs-keyword">OR</span> emp.name = <span class="hljs-string">&#x27;Xyz&#x27;</span>
<span class="hljs-keyword">RETURN</span> emp12</code></pre>

<p>利用<code>WHERE</code>创建指定关系节点：</p>
<pre><code class="hljs groovy">MATCH (<span class="hljs-attr">cust:</span>Customer),(<span class="hljs-attr">cc:</span>CreditCard) 
WHERE cust.id = <span class="hljs-string">&quot;1001&quot;</span> AND cc.id= <span class="hljs-string">&quot;5001&quot;</span> 
CREATE (cust)-[<span class="hljs-attr">r:</span>DO_SHOPPING_WITH&#123;<span class="hljs-attr">shopdate:</span><span class="hljs-string">&quot;12/12/2014&quot;</span>,<span class="hljs-attr">price:</span><span class="hljs-number">55000</span>&#125;]-&gt;(cc) 
RETURN r123</code></pre>

<p>有必要补充一下，可以不使用WHERE达到<code>WHERE</code>的一些效果，比如</p>
<pre><code class="hljs elixir">MATCH p=(<span class="hljs-symbol">m:</span>Bot&#123;<span class="hljs-symbol">id:</span><span class="hljs-number">123</span>&#125;)&lt;-[<span class="hljs-symbol">:BotRelation</span>]-&gt;(<span class="hljs-symbol">:Bot</span>)  RETURN p</code></pre>

<h3 id="6-DELETE删除"><a href="#6-DELETE删除" class="headerlink" title="6.DELETE删除"></a>6.DELETE删除</h3><p>Neo4j使用CQL DELETE子句</p>
<ul>
<li>删除节点。</li>
<li>删除节点及相关节点和关系。</li>
</ul>
<p><strong>DELETE节点子句语法</strong></p>
<pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> &lt;node-<span class="hljs-keyword">name</span>-<span class="hljs-keyword">list</span>&gt;</code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs less"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-attribute">e</span>: Employee) <span class="hljs-selector-tag">DELETE</span> <span class="hljs-selector-tag">e</span></code></pre>

<p><strong>DELETE节点和关系子句语法</strong></p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">DELETE</span> &lt;node1-<span class="hljs-type">name</span>&gt;,&lt;node2-<span class="hljs-type">name</span>&gt;,&lt;relationship-<span class="hljs-type">name</span>&gt;</code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs less"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-attribute">cc</span>: CreditCard)<span class="hljs-selector-tag">-</span><span class="hljs-selector-attr">[rel]</span><span class="hljs-selector-tag">-</span>(<span class="hljs-attribute">c</span>:Customer) 
<span class="hljs-selector-tag">DELETE</span> <span class="hljs-selector-tag">cc</span>,<span class="hljs-selector-tag">c</span>,<span class="hljs-selector-tag">rel1</span></code></pre>

<h3 id="7-REMOVE删除"><a href="#7-REMOVE删除" class="headerlink" title="7.REMOVE删除"></a>7.REMOVE删除</h3><p>有时基于我们的客户端要求，我们需要向现有节点或关系添加或删除属性。</p>
<p>我们使用Neo4j CQL SET子句向现有节点或关系添加新属性。</p>
<p>我们使用Neo4j CQL REMOVE子句来删除节点或关系的现有属性。</p>
<p>Neo4j CQL REMOVE命令用于</p>
<ul>
<li>删除节点或关系的标签</li>
<li>删除节点或关系的属性</li>
</ul>
<p>Neo4j CQL DELETE和REMOVE命令之间的主要区别 -</p>
<ul>
<li>DELETE操作用于删除节点和关联关系。</li>
<li>REMOVE操作用于删除标签和属性。</li>
</ul>
<p>Neo4j CQL DELETE和REMOVE命令之间的相似性 -</p>
<ul>
<li>这两个命令不应单独使用。</li>
<li>两个命令都应该与MATCH命令一起使用。</li>
</ul>
<p><strong>1.REMOVE属性子句语法</strong></p>
<pre><code class="hljs basic"><span class="hljs-comment">REMOVE &lt;node-name&gt;.&lt;property1-name&gt;,&lt;node-name&gt;.&lt;property2-name&gt;</span></code></pre>

<p>语法说明：</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">语法元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"></td>
<td align="left">它是节点的名称。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"></td>
<td align="left">它是节点的属性名称。</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<p>这里我们可以观察到DebitCard节点包含6个属性。</p>
<p>在数据浏览器上键入以下命令删除<code>cvv</code>属性</p>
<pre><code class="hljs properties"><span class="hljs-attr">MATCH</span> <span class="hljs-string">(dc:DebitCard) </span>
<span class="hljs-attr">REMOVE</span> <span class="hljs-string">dc.cvv</span>
<span class="hljs-attr">RETURN</span> <span class="hljs-string">dc12</span></code></pre>

<p><strong>2.REMOVE一个Label子句语法：</strong></p>
<pre><code class="hljs basic"><span class="hljs-comment">REMOVE &lt;label-name-list&gt;</span></code></pre>

<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">语法元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="left">REMOVE</td>
<td align="left">它是一个Neo4j CQL关键字。</td>
</tr>
<tr>
<td align="center">2.</td>
<td align="left"></td>
<td align="left">它是一个标签列表，用于永久性地从节点或关系中删除它。</td>
</tr>
</tbody></table>
<p>语法</p>
<pre><code class="hljs elixir">&lt;node-name&gt;<span class="hljs-symbol">:&lt;label2-name&gt;</span>, 
.... 
&lt;node-name&gt;<span class="hljs-symbol">:&lt;labeln-name&gt;</span> <span class="hljs-number">12</span></code></pre>

<p><strong>示例</strong></p>
<p>1.我们创建一个含有两个标签的节点：</p>
<pre><code class="hljs lisp">CREATE (<span class="hljs-name">m</span><span class="hljs-symbol">:Movie</span><span class="hljs-symbol">:Pic</span>)</code></pre>

<p>2.查询该节点</p>
<pre><code class="hljs lisp">MATCH (<span class="hljs-name">n</span><span class="hljs-symbol">:Movie</span>) RETURN n</code></pre>

<p>3.删除标签</p>
<pre><code class="hljs less"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-attribute">m</span>:Movie) 
<span class="hljs-selector-tag">REMOVE</span> <span class="hljs-selector-tag">m</span><span class="hljs-selector-pseudo">:Pic1</span></code></pre>

<p>4.再次查询</p>
<h3 id="8-SET子句"><a href="#8-SET子句" class="headerlink" title="8.SET子句"></a>8.SET子句</h3><p>有时，根据我们的客户端要求，我们需要向现有节点或关系添加新属性。</p>
<p>要做到这一点，Neo4j CQL提供了一个SET子句。</p>
<p>Neo4j CQL已提供SET子句来执行以下操作。</p>
<ul>
<li>向现有节点或关系添加新属性</li>
<li>添加或更新属性值</li>
</ul>
<p><strong>SET子句语法</strong></p>
<pre><code class="hljs delphi"><span class="hljs-keyword">SET</span>  &lt;node-<span class="hljs-keyword">label</span>-<span class="hljs-keyword">name</span>&gt;.&lt;property1-<span class="hljs-keyword">name</span>&gt;,...&lt;node-laben-<span class="hljs-keyword">name</span>&gt;.&lt;propertyn-<span class="hljs-keyword">name</span>&gt;</code></pre>

<p>语法说明：</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">语法元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">&lt;节点标签名称&gt;</td>
<td align="left">这是一个节点的标签名称。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">&lt;属性名称&gt;</td>
<td align="left">它是一个节点的属性名。</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<pre><code class="hljs gams">MATCH (dc:DebitCard)
<span class="hljs-keyword">SET</span> dc.atm_pin <span class="hljs-comment">= 3456</span>
RETURN <span class="hljs-comment">dc12</span></code></pre>

<h3 id="9-ORDER-BY排序"><a href="#9-ORDER-BY排序" class="headerlink" title="9.ORDER BY排序"></a>9.ORDER BY排序</h3><p><strong>Neo4j CQL ORDER BY子句</strong></p>
<p>Neo4j CQL在MATCH命令中提供了“ORDER BY”子句，对MATCH查询返回的结果进行排序。</p>
<p>我们可以按升序或降序对行进行排序。</p>
<p>默认情况下，它按升序对行进行排序。 如果我们要按降序对它们进行排序，我们需要使用DESC子句。</p>
<p><strong>ORDER BY子句语法</strong></p>
<pre><code class="hljs oxygene"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  &lt;<span class="hljs-keyword">property</span>-name-list&gt;  [<span class="hljs-keyword">DESC</span>]</code></pre>

<p><strong>语法：</strong></p>
<pre><code class="hljs delphi">&lt;node-<span class="hljs-keyword">label</span>-<span class="hljs-keyword">name</span>&gt;.&lt;property1-<span class="hljs-keyword">name</span>&gt;,
&lt;node-<span class="hljs-keyword">label</span>-<span class="hljs-keyword">name</span>&gt;.&lt;property2-<span class="hljs-keyword">name</span>&gt;, 
.... 
&lt;node-<span class="hljs-keyword">label</span>-<span class="hljs-keyword">name</span>&gt;.&lt;propertyn-<span class="hljs-keyword">name</span>&gt; <span class="hljs-number">123</span></code></pre>

<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="center">语法元素</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"></td>
<td align="center">它是节点的标签名称。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">它是节点的属性名称。</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">emp</span><span class="hljs-selector-pseudo">:Employee)</span>
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">emp</span><span class="hljs-selector-class">.empid</span>,<span class="hljs-selector-tag">emp</span><span class="hljs-selector-class">.name</span>,<span class="hljs-selector-tag">emp</span><span class="hljs-selector-class">.salary</span>,<span class="hljs-selector-tag">emp</span><span class="hljs-selector-class">.deptno</span>
<span class="hljs-selector-tag">ORDER</span> <span class="hljs-selector-tag">BY</span> <span class="hljs-selector-tag">emp</span><span class="hljs-selector-class">.name12</span></code></pre>

<h3 id="10-UNION子句"><a href="#10-UNION子句" class="headerlink" title="10.UNION子句"></a>10.UNION子句</h3><p>与SQL一样，Neo4j CQL有两个子句，将两个不同的结果合并成一组结果</p>
<ul>
<li>UNION</li>
<li>UNION ALL</li>
</ul>
<p><strong>UNION子句</strong></p>
<p>它将两组结果中的公共行组合并返回到一组结果中。 它不从两个节点返回重复的行。</p>
<p>限制：</p>
<p>结果列类型和来自两组结果的名称必须匹配，这意味着列名称应该相同，列的数据类型应该相同。</p>
<p><strong>UNION子句语法</strong></p>
<pre><code class="hljs apache"><span class="hljs-section">&lt;MATCH Command1&gt;</span>
   <span class="hljs-attribute">UNION</span>
<span class="hljs-section">&lt;MATCH Command2&gt;</span><span class="hljs-attribute">12</span></code></pre>

<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">语法元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"></td>
<td align="left">它是CQL MATCH命令，由UNION子句使用。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"></td>
<td align="left">它是CQL MATCH命令两个由UNION子句使用。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">UNION</td>
<td align="left">它是UNION子句的Neo4j CQL关键字。</td>
</tr>
</tbody></table>
<p><strong>注意 -</strong></p>
<p>如果这两个查询不返回相同的列名和数据类型，那么它抛出一个错误。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">cc</span><span class="hljs-selector-pseudo">:CreditCard)</span> <span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">cc</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">cc</span><span class="hljs-selector-class">.number</span>
<span class="hljs-selector-tag">UNION</span>
<span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">dc</span><span class="hljs-selector-pseudo">:DebitCard)</span> <span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">dc</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">dc</span><span class="hljs-selector-class">.number12</span></code></pre>

<p><strong>UNION ALL子句</strong></p>
<p>它结合并返回两个结果集的所有行成一个单一的结果集。它还返回由两个节点重复行。</p>
<p><strong>限制</strong></p>
<p>结果列类型，并从两个结果集的名字必须匹配，这意味着列名称应该是相同的，列的数据类型应该是相同的。</p>
<p><strong>UNION ALL子句语法</strong></p>
<pre><code class="hljs apache"><span class="hljs-section">&lt;MATCH Command1&gt;</span>
<span class="hljs-attribute">UNION</span> <span class="hljs-literal">ALL</span>
<span class="hljs-section">&lt;MATCH Command2&gt;</span><span class="hljs-attribute">12</span></code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">cc</span><span class="hljs-selector-pseudo">:CreditCard)</span> <span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">cc</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">cc</span><span class="hljs-selector-class">.number</span>
<span class="hljs-selector-tag">UNION</span> <span class="hljs-selector-tag">ALL</span>
<span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">dc</span><span class="hljs-selector-pseudo">:DebitCard)</span> <span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">dc</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">dc</span><span class="hljs-selector-class">.number12</span></code></pre>

<h3 id="11-LIMIT和SKIP子句"><a href="#11-LIMIT和SKIP子句" class="headerlink" title="11.LIMIT和SKIP子句"></a>11.LIMIT和SKIP子句</h3><p>Neo4j CQL已提供<code>LIMIT</code>子句和<code>SKIP</code>来过滤或限制查询返回的行数。</p>
<p><strong>简单来说：LIMIT返回前几行，SKIP返回后几行。</strong></p>
<p><code>LIMIT</code> <strong>示例</strong></p>
<pre><code class="hljs lisp">MATCH (<span class="hljs-name">emp</span><span class="hljs-symbol">:Employee</span>) 
RETURN emp
LIMIT <span class="hljs-number">212</span></code></pre>

<p>它只返回Top的两个结果，因为我们定义了limit = 2。这意味着前两行。</p>
<p><code>SKIP</code><strong>示例</strong></p>
<pre><code class="hljs subunit">MATCH (emp:Employee) 
RETURN emp
<span class="hljs-keyword">SKIP </span>212</code></pre>

<p>它只返回来自Bottom的两个结果，因为我们定义了skip = 2。这意味着最后两行。</p>
<h3 id="12-MERGE命令"><a href="#12-MERGE命令" class="headerlink" title="12.MERGE命令"></a>12.MERGE命令</h3><p>Neo4j使用CQL MERGE命令 -</p>
<ul>
<li>创建节点，关系和属性</li>
<li>为从数据库检索数据</li>
</ul>
<p>MERGE命令是CREATE命令和MATCH命令的组合。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">MERGE</span> = <span class="hljs-keyword">CREATE</span> + <span class="hljs-keyword">MATCH</span></code></pre>

<p>Neo4j CQL MERGE命令在图中搜索给定模式，如果存在，则返回结果</p>
<p>如果它不存在于图中，则它创建新的节点/关系并返回结果。</p>
<p><strong>Neo4j CQL MERGE语法</strong></p>
<pre><code class="hljs elixir">MERGE (&lt;node-name&gt;<span class="hljs-symbol">:&lt;label-name&gt;</span>
&#123;
   &lt;key&gt;<span class="hljs-symbol">:&lt;</span><span class="hljs-number">1</span>-Value&gt;
   .....
   &lt;n-key&gt;<span class="hljs-symbol">:&lt;n-Value&gt;</span>
&#125;)<span class="hljs-number">12345</span></code></pre>

<p><strong>注意 -</strong></p>
<p>Neo4j CQL MERGE命令语法与CQL CREATE命令类似。</p>
<p>我们将使用这两个命令执行以下操作 -</p>
<ul>
<li>创建具有一个属性的配置文件节点：Id，名称</li>
<li>创建具有相同属性的同一个Profile节点：Id，Name</li>
<li>检索所有Profile节点详细信息并观察结果</li>
</ul>
<p>我们将使用CREATE命令执行这些操作：</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MERGE</span> (<span class="hljs-selector-tag">gp2</span><span class="hljs-selector-pseudo">:GoogleProfile2</span>&#123; <span class="hljs-attribute">Id</span>: <span class="hljs-number">201402</span>,Name:<span class="hljs-string">&quot;Nokia&quot;</span>&#125;)
<span class="hljs-selector-tag">MERGE</span> (<span class="hljs-selector-tag">gp2</span><span class="hljs-selector-pseudo">:GoogleProfile2</span>&#123; <span class="hljs-attribute">Id</span>: <span class="hljs-number">201402</span>,Name:<span class="hljs-string">&quot;Nokia&quot;</span>&#125;)
<span class="hljs-selector-tag">MATCH</span>  (<span class="hljs-selector-tag">gp1</span><span class="hljs-selector-pseudo">:GoogleProfile1)</span> 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">gp1</span><span class="hljs-selector-class">.Id</span>,<span class="hljs-selector-tag">gp1</span><span class="hljs-selector-class">.Name1</span></code></pre>

<p>如果我们观察上面的查询结果，它只显示一行，因为CQL MERGE命令检查该节点在数据库中是否可用。 如果它不存在，它创建新节点。 否则，它不创建新的。</p>
<p>通过观察这些结果，我们可以说，CQL MERGE命令将新的节点添加到数据库，只有当它不存在。</p>
<h3 id="13-NULL值"><a href="#13-NULL值" class="headerlink" title="13.NULL值"></a>13.NULL值</h3><p>Neo4j CQL将空值视为对节点或关系的属性的缺失值或未定义值。</p>
<p>当我们创建一个具有现有节点标签名称但未指定其属性值的节点时，它将创建一个具有NULL属性值的新节点。</p>
<p>让我们用一个例子来看这个。</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">e</span><span class="hljs-selector-pseudo">:Employee)</span> 
<span class="hljs-selector-tag">WHERE</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span> <span class="hljs-selector-tag">IS</span> <span class="hljs-selector-tag">NOT</span> <span class="hljs-selector-tag">NULL</span>
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.name</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.sal</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.deptno12</span></code></pre>

<p>提供了一个WHERE子句来过滤该行，即Id属性不应该包含NULL值。</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">e</span><span class="hljs-selector-pseudo">:Employee)</span> 
<span class="hljs-selector-tag">WHERE</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span> <span class="hljs-selector-tag">IS</span> <span class="hljs-selector-tag">NULL</span>
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.name</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.sal</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.deptno12</span></code></pre>

<p>这里我们使用IS操作符来仅返回NULL行。</p>
<h3 id="14-IN操作符"><a href="#14-IN操作符" class="headerlink" title="14.IN操作符"></a>14.IN操作符</h3><p>与SQL一样，Neo4j CQL提供了一个IN运算符，以便为CQL命令提供值的集合。</p>
<p><strong>IN操作符语法</strong></p>
<pre><code class="hljs fsharp">IN<span class="hljs-meta">[&lt;Collection-of-values&gt;]</span></code></pre>

<p>它是由逗号运算符分隔的值的集合。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">e</span><span class="hljs-selector-pseudo">:Employee)</span> 
<span class="hljs-selector-tag">WHERE</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span> <span class="hljs-selector-tag">IN</span> <span class="hljs-selector-attr">[123,124]</span>
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.name</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.sal</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.deptno12</span></code></pre>

<h3 id="15-INDEX索引"><a href="#15-INDEX索引" class="headerlink" title="15.INDEX索引"></a>15.INDEX索引</h3><p>Neo4j SQL支持节点或关系属性上的索引，以提高应用程序的性能。</p>
<p>我们可以为具有相同标签名称的所有节点的属性创建索引。</p>
<p>我们可以在MATCH或WHERE或IN运算符上使用这些索引列来改进CQL Command的执行。</p>
<p><strong>Neo4J索引操作</strong></p>
<ul>
<li>Create Index 创建索引</li>
<li>Drop Index 丢弃索引</li>
</ul>
<p>我们将在本章中用示例来讨论这些操作。</p>
<p><strong>创建索引的语法：</strong></p>
<pre><code class="hljs elixir">CREATE INDEX ON <span class="hljs-symbol">:&lt;label_name&gt;</span> (&lt;property_name&gt;)</code></pre>

<p><strong>注意：-</strong></p>
<p>冒号（:)运算符用于引用节点或关系标签名称。</p>
<p>上述语法描述它在节点或关系的的上创建一个新索引。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> :Customer (<span class="hljs-type">name</span>)</code></pre>

<p><strong>删除索引的语法：</strong></p>
<pre><code class="hljs elixir">DROP INDEX ON <span class="hljs-symbol">:&lt;label_name&gt;</span> (&lt;property_name&gt;)</code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> :Customer (<span class="hljs-type">name</span>)</code></pre>

<h3 id="16-UNIQUE约束"><a href="#16-UNIQUE约束" class="headerlink" title="16.UNIQUE约束"></a>16.UNIQUE约束</h3><p>在Neo4j数据库中，CQL CREATE命令始终创建新的节点或关系，这意味着即使您使用相同的值，它也会插入一个新行。 根据我们对某些节点或关系的应用需求，我们必须避免这种重复。 然后我们不能直接得到这个。 我们应该使用一些数据库约束来创建节点或关系的一个或多个属性的规则。</p>
<p>像SQL一样，Neo4j数据库也支持对NODE或Relationship的属性的UNIQUE约束</p>
<p><strong>UNIQUE约束的优点</strong></p>
<ul>
<li>避免重复记录。</li>
<li>强制执行数据完整性规则</li>
</ul>
<p><strong>创建唯一约束语法</strong></p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-keyword">ON</span> (&lt;label_name&gt;)
<span class="hljs-keyword">ASSERT</span> &lt;property_name&gt; <span class="hljs-keyword">IS</span> UNIQUE1</code></pre>

<p>语法说明：</p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">语法元素</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">CREATE CONSTRAINT ON</td>
<td align="left">它是一个Neo4j CQL关键字。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"></td>
<td align="left">它是节点或关系的标签名称。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">ASSERT</td>
<td align="left">它是一个Neo4j CQL关键字。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"></td>
<td align="left">它是节点或关系的属性名称。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">IS UNIQUE</td>
<td align="left">它是一个Neo4j CQL关键字，通知Neo4j数据库服务器创建一个唯一约束。</td>
</tr>
</tbody></table>
<p><strong>注意：-</strong></p>
<p>上述语法描述了只需要 节点或关系就可以创造一个独特的约束。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-keyword">ON</span> (cc:CreditCard)
<span class="hljs-keyword">ASSERT</span> cc.number <span class="hljs-keyword">IS</span> UNIQUE1</code></pre>

<p><strong>注意</strong></p>
<p>如果创建约束时节点属性有重复值，Neo4j DB服务器将会抛出一个错误，表示无法创建。</p>
<p><strong>删除UNIQUE约束语法：</strong></p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-keyword">ON</span> (&lt;label_name&gt;)
<span class="hljs-keyword">ASSERT</span> &lt;property_name&gt; <span class="hljs-keyword">IS</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-number">1</span></code></pre>

<p><strong>示例</strong></p>
<pre><code class="hljs stata"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-keyword">ON</span> (<span class="hljs-keyword">cc</span>:CreditCard)
<span class="hljs-keyword">ASSERT</span> <span class="hljs-keyword">cc</span>.number IS UNIQUE1</code></pre>

<h3 id="17-DISTINCT独特"><a href="#17-DISTINCT独特" class="headerlink" title="17.DISTINCT独特"></a>17.DISTINCT独特</h3><p>这个函数的用法就像SQL中的distinct关键字，返回的是所有不同值。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs lisp">MATCH (<span class="hljs-name">n</span><span class="hljs-symbol">:Movie</span>) RETURN Distinct(<span class="hljs-name">n</span>.name)</code></pre>

<p>返回的是</p>
<h2 id="第五章：解释"><a href="#第五章：解释" class="headerlink" title="第五章：解释"></a>第五章：解释</h2><h3 id="1-图形字体"><a href="#1-图形字体" class="headerlink" title="1.图形字体"></a>1.图形字体</h3><p>关于Neo4j提供的图形浏览器，我们可以从其中查看节点的属性，或者改变其中的节点的大小颜色。</p>
<h3 id="2-ID属性"><a href="#2-ID属性" class="headerlink" title="2.ID属性"></a>2.ID属性</h3><p>在Neo4j中，“Id”是节点和关系的默认内部属性。 这意味着，当我们创建一个新的节点或关系时，Neo4j数据库服务器将为内部使用分配一个数字。 它会自动递增。</p>
<p>我们从一个例子去看：</p>
<p>新增一个节点</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">CREATE</span> (<span class="hljs-selector-tag">tweet</span><span class="hljs-selector-pseudo">:Tweet</span>&#123;<span class="hljs-attribute">message</span>:<span class="hljs-string">&quot;Hello&quot;</span>&#125;)</code></pre>

<p>查看该节点</p>
<pre><code class="hljs lisp">MATCH (<span class="hljs-name">n</span><span class="hljs-symbol">:Tweet</span>) RETURN n</code></pre>

<h3 id="3-Caption标题"><a href="#3-Caption标题" class="headerlink" title="3.Caption标题"></a>3.Caption标题</h3><p>所谓的Caption标题，就是更改Neo4j浏览器的节点显示的文字（圆圈内部）。比如</p>
<p>我们点击下图所示：</p>
<p>圆圈内部变为了id值。</p>
<h2 id="第六章：函数"><a href="#第六章：函数" class="headerlink" title="第六章：函数"></a>第六章：函数</h2><h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="1.字符串函数"></a>1.字符串函数</h3><p>与SQL一样，Neo4J CQL提供了一组String函数，用于在CQL查询中获取所需的结果。</p>
<p>这里我们将讨论一些重要的和经常使用的功能。</p>
<p><strong>字符串函数列表</strong></p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">功能</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">UPPER</td>
<td align="left">它用于将所有字母更改为大写字母。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">LOWER</td>
<td align="left">它用于将所有字母改为小写字母。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">SUBSTRING</td>
<td align="left">它用于获取给定String的子字符串。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">REPLACE</td>
<td align="left">它用于替换一个字符串的子字符串。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>所有CQL函数应使用“（）”括号。</p>
<p>现在我们将通过示例详细讨论每个Neo4J CQL字符串函数</p>
<p>1.<strong>UPPER</strong></p>
<p>它需要一个字符串作为输入并转换为大写字母。 所有CQL函数应使用“（）”括号。</p>
<p><strong>函数语法</strong></p>
<pre><code class="hljs gauss"><span class="hljs-built_in">UPPER</span> (&lt;input-<span class="hljs-keyword">string</span>&gt;)</code></pre>

<p><strong>注意：-</strong></p>
<p>可以是来自Neo4J数据库的节点或关系的属性名称。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">e</span><span class="hljs-selector-pseudo">:Employee)</span> 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">UPPER</span>(<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.name</span>),<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.sal</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.deptno1</span></code></pre>

<p>2.<strong>LOWER</strong></p>
<p>它需要一个字符串作为输入并转换为小写字母。 所有CQL函数应使用“（）”括号。</p>
<p><strong>函数语法</strong></p>
<pre><code class="hljs gauss"><span class="hljs-built_in">LOWER</span> (&lt;input-<span class="hljs-keyword">string</span>&gt;)</code></pre>

<p><strong>注意：-</strong></p>
<p>可以是来自Neo4J数据库的节点或关系的属性名称</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">e</span><span class="hljs-selector-pseudo">:Employee)</span> 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">LOWER</span>(<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.name</span>),<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.sal</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.deptno1</span></code></pre>

<p>3.<strong>SUBSTRING</strong></p>
<p>它接受一个字符串作为输入和两个索引：一个是索引的开始，另一个是索引的结束，并返回从StartInded到EndIndex-1的子字符串。 所有CQL函数应使用“（）”括号。</p>
<p><strong>函数的语法</strong></p>
<pre><code class="hljs reasonml"><span class="hljs-constructor">SUBSTRING(&lt;<span class="hljs-params">input</span>-<span class="hljs-params">string</span>&gt;,&lt;<span class="hljs-params">startIndex</span>&gt; ,&lt;<span class="hljs-params">endIndex</span>&gt;)</span></code></pre>

<p><strong>注意：-</strong></p>
<p>在Neo4J CQL中，如果一个字符串包含n个字母，则它的长度为n，索引从0开始，到n-1结束。</p>
<p>是SUBSTRING函数的索引值。</p>
<p>是可选的。 如果我们省略它，那么它返回给定字符串的子串从startIndex到字符串的结尾。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs css"><span class="hljs-selector-tag">MATCH</span> (<span class="hljs-selector-tag">e</span><span class="hljs-selector-pseudo">:Employee)</span> 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.id</span>,<span class="hljs-selector-tag">SUBSTRING</span>(<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.name</span>,0,2),<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.sal</span>,<span class="hljs-selector-tag">e</span><span class="hljs-selector-class">.deptno1</span></code></pre>

<h3 id="2-AGGREGATION聚合"><a href="#2-AGGREGATION聚合" class="headerlink" title="2.AGGREGATION聚合"></a>2.AGGREGATION聚合</h3><p>和SQL一样，Neo4j CQL提供了一些在RETURN子句中使用的聚合函数。 它类似于SQL中的GROUP BY子句。</p>
<p>我们可以使用MATCH命令中的RETURN +聚合函数来处理一组节点并返回一些聚合值。</p>
<p><strong>聚合函数列表</strong></p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">聚集功能</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">COUNT</td>
<td align="left">它返回由MATCH命令返回的行数。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">MAX</td>
<td align="left">它从MATCH命令返回的一组行返回最大值。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">MIN</td>
<td align="left">它返回由MATCH命令返回的一组行的最小值。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">SUM</td>
<td align="left">它返回由MATCH命令返回的所有行的求和值。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">AVG</td>
<td align="left">它返回由MATCH命令返回的所有行的平均值。</td>
</tr>
</tbody></table>
<p>现在我们将通过示例详细讨论每个Neo4j CQL AGGREGATION函数</p>
<p><strong>计数</strong></p>
<p>它从MATCH子句获取结果，并计算结果中出现的行数，并返回该计数值。 所有CQL函数应使用“（）”括号。</p>
<p><strong>函数语法</strong></p>
<pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">COUNT</span><span class="hljs-params">(&lt;value&gt;)</span></span></code></pre>

<p><strong>注意 -</strong></p>
<p>可以是*，节点或关系标签名称或属性名称。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs lisp">MATCH (<span class="hljs-name">e</span><span class="hljs-symbol">:Employee</span>) RETURN COUNT(<span class="hljs-name">*</span>)</code></pre>

<p><strong>MAX</strong></p>
<p>它采用一组行和节点或关系的作为输入，并从给定行的give 列中查找最小值。</p>
<p><strong>函数语法</strong></p>
<pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">MAX</span></span>(&lt;<span class="hljs-variable">property</span>-<span class="hljs-variable">name</span>&gt; )</span></code></pre>

<p><strong>MIN</strong></p>
<p>它采用一组行和节点或关系的作为输入，并从给定行的give 列中查找最小值。</p>
<p><strong>函数语法</strong></p>
<pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">MIN</span></span>(&lt;<span class="hljs-variable">property</span>-<span class="hljs-variable">name</span>&gt; )</span></code></pre>

<p><strong>注意 -</strong></p>
<p>应该是节点或关系的名称。</p>
<p>让我们用一个例子看看MAX和MIN的功能。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs reasonml">MATCH (e:Employee) 
RETURN <span class="hljs-constructor">MAX(<span class="hljs-params">e</span>.<span class="hljs-params">sal</span>)</span>,<span class="hljs-constructor">MIN(<span class="hljs-params">e</span>.<span class="hljs-params">sal</span>)</span><span class="hljs-number">1</span></code></pre>

<p><strong>AVG</strong></p>
<p>它采用一组行和节点或关系的作为输入，并从给定行的give 列中查找平均值。</p>
<p><strong>函数的语法</strong></p>
<pre><code class="hljs reasonml"><span class="hljs-constructor">AVG(&lt;<span class="hljs-params">property</span>-<span class="hljs-params">name</span>&gt; )</span></code></pre>

<p><strong>SUM</strong></p>
<p>它采用一组行和节点或关系的作为输入，并从给定行的give 列中查找求和值。</p>
<p><strong>函数的语法</strong></p>
<pre><code class="hljs reasonml"><span class="hljs-constructor">SUM(&lt;<span class="hljs-params">property</span>-<span class="hljs-params">name</span>&gt; )</span></code></pre>

<p>让我们用一个例子来检查SUM和AVG函数。</p>
<pre><code class="hljs reasonml">MATCH (e:Employee) 
RETURN <span class="hljs-constructor">SUM(<span class="hljs-params">e</span>.<span class="hljs-params">sal</span>)</span>,<span class="hljs-constructor">AVG(<span class="hljs-params">e</span>.<span class="hljs-params">sal</span>)</span><span class="hljs-number">1</span></code></pre>

<p>此命令从数据库中可用的所有Employee节点查找总和平均值.</p>
<h3 id="3-关系函数"><a href="#3-关系函数" class="headerlink" title="3.关系函数"></a>3.关系函数</h3><p>Neo4j CQL提供了一组关系函数，以在获取开始节点，结束节点等细节时知道关系的细节。</p>
<p><strong>关系函数列表</strong></p>
<table>
<thead>
<tr>
<th align="center">S.No.</th>
<th align="left">功能</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">STARTNODE</td>
<td align="left">它用于知道关系的开始节点。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">ENDNODE</td>
<td align="left">它用于知道关系的结束节点。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">ID</td>
<td align="left">它用于知道关系的ID。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">TYPE</td>
<td align="left">它用于知道字符串表示中的一个关系的TYPE。</td>
</tr>
</tbody></table>
<p>现在我们将通过示例详细讨论每个Neo4j CQL关系函数</p>
<p><strong>STARTNODE</strong></p>
<p>它需要一个字符串作为输入并转换为大写字母。 所有CQL函数应使用“（）”括号。</p>
<p><strong>函数语法</strong></p>
<pre><code class="hljs delphi">STARTNODE (&lt;relationship-<span class="hljs-keyword">label</span>-<span class="hljs-keyword">name</span>&gt;)</code></pre>

<p><strong>注意：-</strong></p>
<p>可以是来自Neo4j数据库的节点或关系的属性名称。</p>
<p><strong>示例</strong></p>
<pre><code class="hljs less"><span class="hljs-selector-tag">MATCH</span> (a)<span class="hljs-selector-tag">-</span><span class="hljs-selector-attr">[movie:ACTION_MOVIES]</span><span class="hljs-selector-tag">-</span>&gt;(b) 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">STARTNODE</span>(movie)<span class="hljs-selector-tag">1</span></code></pre>

<p><strong>ENDNODE</strong></p>
<pre><code class="hljs less"><span class="hljs-selector-tag">MATCH</span> (a)<span class="hljs-selector-tag">-</span><span class="hljs-selector-attr">[movie:ACTION_MOVIES]</span><span class="hljs-selector-tag">-</span>&gt;(b) 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">ENDNODE</span>(movie)<span class="hljs-selector-tag">1</span></code></pre>

<p><strong>ID TYPE</strong></p>
<pre><code class="hljs less"><span class="hljs-selector-tag">MATCH</span> (a)<span class="hljs-selector-tag">-</span><span class="hljs-selector-attr">[movie:ACTION_MOVIES]</span><span class="hljs-selector-tag">-</span>&gt;(b) 
<span class="hljs-selector-tag">RETURN</span> <span class="hljs-selector-tag">ID</span>(movie),<span class="hljs-selector-tag">TYPE</span>(movie)<span class="hljs-selector-tag">1</span></code></pre>

<h2 id="第七章：管理员"><a href="#第七章：管理员" class="headerlink" title="第七章：管理员"></a>第七章：管理员</h2><h3 id="1-数据库备份"><a href="#1-数据库备份" class="headerlink" title="1.数据库备份"></a>1.数据库备份</h3><p>在对Neo4j数据进行备份、还原、迁移的操作时，首先要关闭neo4j;</p>
<pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> %NEO4J_HOME%<span class="hljs-string">/bin</span>
<span class="hljs-string">./neo4j</span> stop</code></pre>

<p>数据备份到文件</p>
<pre><code class="hljs routeros">./neo4j-admin  dump <span class="hljs-attribute">--database</span>=graph.db <span class="hljs-attribute">--to</span>=/home/2018.dump</code></pre>

<p>之后，进行数据还原，将生成的存储文件拷贝到另一个相同版本的环境中。</p>
<h3 id="2-数据库恢复"><a href="#2-数据库恢复" class="headerlink" title="2.数据库恢复"></a>2.数据库恢复</h3><p>还原、迁移之前 ，关闭neo4j服务。操作同上；</p>
<p>数据导入：</p>
<pre><code class="hljs angelscript">./neo4j-admin load --<span class="hljs-keyword">from</span>=/home/<span class="hljs-number">2016</span><span class="hljs-number">-10</span><span class="hljs-number">-02.</span>dump --database=graph.db --force</code></pre>

<p>重启服务：</p>
<pre><code class="hljs crmsh">./neo4j <span class="hljs-literal">start</span></code></pre>

<h2 id="附录-neo4j-conf汉化版"><a href="#附录-neo4j-conf汉化版" class="headerlink" title="附录 neo4j.conf汉化版"></a>附录 neo4j.conf汉化版</h2><pre><code class="hljs nix">For more details <span class="hljs-literal">and</span> a complete list of settings, please see https://neo4j.com/docs/operations-manual/current/reference/configuration-settings/

如果想自定义neo4j数据库数据的存储路径，要同时修改dbms.active_database 和 dbms.directories.data 两项配置，修改配置后，数据会存放在 &#123;dbms.active_database&#125; 目录下

安装的数据库的名称，默认使用 $&#123;NEO4J_HOME&#125;/data/databases/graph.db 目录

The name of the database to mount
<span class="hljs-comment">#dbms.active_database=graph.db</span>

<span class="hljs-comment">#安装Neo4j数据库的各个配置路径，默认使用$NEO4J_HOME下的路径</span>

<span class="hljs-comment">#Paths of directories in the installation.</span>

数据路径

<span class="hljs-comment">#dbms.directories.data=data</span>

插件路径
<span class="hljs-comment">#dbms.directories.plugins=plugins</span>
<span class="hljs-comment">#dbms.directories.certificates=certificates 证书路径</span>
<span class="hljs-comment">#dbms.directories.logs=logs 日志路径</span>
<span class="hljs-comment">#dbms.directories.lib=lib jar包路径</span>
<span class="hljs-comment">#dbms.directories.run=run 运行路径</span>

默认情况下想load csv文件，只能把csv文件放到  $&#123;NEO4J_HOME&#125;/<span class="hljs-built_in">import</span> 目录下，把下面的 <span class="hljs-comment"># 删除后，可以在load csv时使用绝对路径，这样可能不安全</span>

<span class="hljs-comment">#This setting constrains all `LOAD CSV` import files to be under the `import` directory. Remove or comment it out to allow files to be loaded from anywhere in the filesystem; this introduces possible security problems. See the `LOAD CSV` section of the manual for details.</span>
<span class="hljs-comment">#此设置将所有“LOAD CSV”导入文件限制在`import`目录下。删除注释允许从文件系统的任何地方加载文件;</span>
这引入了可能的安全问题。

dbms.directories.<span class="hljs-attr">import=import</span>

<span class="hljs-comment">#把下面这行的#删掉后，连接neo4j数据库时就不用输密码了</span>

<span class="hljs-comment">#Whether requests to Neo4j are authenticated. 是否对Neo4j的请求进行了身份验证。</span>
<span class="hljs-comment">#To disable authentication, uncomment this line 要禁用身份验证，请取消注释此行。</span>

<span class="hljs-comment">#dbms.security.auth_enabled=false</span>

<span class="hljs-comment">#Enable this to be able to upgrade a store from an older version. 是否兼容以前版本的数据</span>
dbms.<span class="hljs-attr">allow_format_migration=true</span>

<span class="hljs-comment">#Java Heap Size: by default the Java heap size is dynamically calculated based on available system resources. Java</span>
堆大小：默认情况下，Java堆大小是动态地根据可用的系统资源计算。

<span class="hljs-comment">#Uncomment these lines to set specific initial and maximum heap size. </span>
取消注释这些行以设置特定的初始值和最大值

<span class="hljs-comment">#dbms.memory.heap.initial_size=512m</span>
<span class="hljs-comment">#dbms.memory.heap.max_size=512m</span>

<span class="hljs-comment">#The amount of memory to use for mapping the store files, in bytes (or kilobytes with the ‘k’ suffix, megabytes with ‘m’ and gigabytes with ‘g’). </span>
用于映射存储文件的内存量（以字节为单位）千字节带有’k’后缀，兆字节带有’m’，千兆字节带有’g’）。

<span class="hljs-comment">#If Neo4j is running on a dedicated server, then it is generally recommended to leave about 2-4 gigabytes for the operating system, give the JVM enough heap to hold all your transaction state and query context, and then leave the rest for the page cache. </span>
如果Neo4j在专用服务器上运行，那么通常建议为操作系统保留大约<span class="hljs-number">2</span>-<span class="hljs-number">4</span>千兆字节，为JVM提供足够的堆来保存所有的事务状态和查询上下文，然后保留其余的页面缓存 。

<span class="hljs-comment">#The default page cache memory assumes the machine is dedicated to running Neo4j, and is heuristically set to 50% of RAM minus the max Java heap size.</span>
默认页面缓存存储器假定机器专用于运行Neo4j，并且试探性地设置为RAM的<span class="hljs-number">50</span>％减去最大Java堆大小。
<span class="hljs-comment">#dbms.memory.pagecache.size=10g</span>

<span class="hljs-comment">### Network connector configuration</span>

<span class="hljs-comment">#With default configuration Neo4j only accepts local connections. Neo4j默认只接受本地连接(localhost)</span>
<span class="hljs-comment">#To accept non-local connections, uncomment this line: 要接受非本地连接，请取消注释此行</span>

dbms.connectors.<span class="hljs-attr">default_listen_address=0.0.0.0</span> (这是删除<span class="hljs-comment">#后的配置，可以通过ip访问)</span>

<span class="hljs-comment">#You can also choose a specific network interface, and configure a non-default port for each connector, by setting their individual listen_address. </span>
还可以选择特定的网络接口，并配置非默认值端口，设置它们各自的 listen_address

<span class="hljs-comment">#The address at which this server can be reached by its clients. This may be the server’s IP address or DNS name, or it may be the address of a reverse proxy which sits in front of the server. This setting may be overridden for individual connectors below. </span>
客户端可以访问此服务器的地址。这可以是服务器的IP地址或DNS名称，或者可以是位于服务器前面的反向代理的地址。此设置可能会覆盖以下各个连接器。
<span class="hljs-comment">#dbms.connectors.default_advertised_address=localhost</span>

<span class="hljs-comment">#You can also choose a specific advertised hostname or IP address, and configure an advertised port for each connector, by setting their individual advertised_address. </span>
您还可以选择特定广播主机名或IP地址，为每个连接器配置通告的端口，通过设置它们独特的 advertised_address。

<span class="hljs-comment">#Bolt connector 使用Bolt协议</span>
dbms.connector.bolt.<span class="hljs-attr">enabled=true</span>
dbms.connector.bolt.<span class="hljs-attr">tls_level=OPTIONAL</span>
dbms.connector.bolt.<span class="hljs-attr">listen_address=:7687</span>

<span class="hljs-comment">#HTTP Connector. There must be exactly one HTTP connector. 使用http协议</span>
dbms.connector.http.<span class="hljs-attr">enabled=true</span>
dbms.connector.http.<span class="hljs-attr">listen_address=:7474</span>

<span class="hljs-comment">#HTTPS Connector. There can be zero or one HTTPS connectors. 使用https协议</span>
dbms.connector.https.<span class="hljs-attr">enabled=true</span>
dbms.connector.https.<span class="hljs-attr">listen_address=:7473</span>

<span class="hljs-comment">#Number of Neo4j worker threads. Neo4j线程数</span>
<span class="hljs-comment">#dbms.threads.worker_count=</span>

<span class="hljs-comment">#Logging configuration 日志配置</span>

<span class="hljs-comment">#To enable HTTP logging, uncomment this line 要启用HTTP日志记录，请取消注释此行</span>
dbms.logs.http.<span class="hljs-attr">enabled=true</span>

<span class="hljs-comment">#Number of HTTP logs to keep. 要保留的HTTP日志数</span>
<span class="hljs-comment">#dbms.logs.http.rotation.keep_number=5</span>

<span class="hljs-comment">#Size of each HTTP log that is kept. 每个HTTP日志文件的大小</span>
dbms.logs.http.rotation.<span class="hljs-attr">size=20m</span>

<span class="hljs-comment">#To enable GC Logging, uncomment this line 要启用GC日志记录，请取消注释此行</span>
<span class="hljs-comment">#dbms.logs.gc.enabled=true</span>

<span class="hljs-comment">#GC Logging Options see http://docs.oracle.com/cd/E19957-01/819-0084-10/pt_tuningjava.html#wp57013 for more information. GC日志记录选项 有关详细信息，请参见http://docs.oracle.com/cd/E19957-01/819-0084-10/pt_tuningjava.html#wp57013</span>
<span class="hljs-comment">#dbms.logs.gc.options=-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintPromotionFailure -XX:+PrintTenuringDistribution</span>

<span class="hljs-comment">#Number of GC logs to keep. 要保留的GC日志数</span>
<span class="hljs-comment">#dbms.logs.gc.rotation.keep_number=5</span>

<span class="hljs-comment">#Size of each GC log that is kept. 保留的每个GC日志文件的大小</span>
<span class="hljs-comment">#dbms.logs.gc.rotation.size=20m</span>

<span class="hljs-comment">#Size threshold for rotation of the debug log. If set to zero then no rotation will occur. Accepts a binary suffix “k”, “m” or “g”. 调试日志旋转的大小阈值。如果设置为零，则不会发生滚动(达到指定大小后切割日志文件)。接受二进制后缀“k”，“m”或“g”。</span>
<span class="hljs-comment">#dbms.logs.debug.rotation.size=20m</span>

<span class="hljs-comment">#Maximum number of history files for the internal log. 最多保存几个日志文件</span>
<span class="hljs-comment">#dbms.logs.debug.rotation.keep_number=7</span>

<span class="hljs-comment">### Miscellaneous configuration 其他配置</span>

<span class="hljs-comment">#Enable this to specify a parser other than the default one. 启用此选项可指定除默认解析器之外的解析器</span>
<span class="hljs-comment">#cypher.default_language_version=3.0</span>

<span class="hljs-comment">#Determines if Cypher will allow using file URLs when loading data using `LOAD CSV`. Setting this value to `false` will cause Neo4j to fail `LOAD CSV` clauses that load data from the file system. 确定当使用加载数据时，Cypher是否允许使用文件URL `LOAD CSV`。将此值设置为`false`将导致Neo4j不能通过互联网上的URL导入数据，`LOAD CSV` 会从文件系统加载数据。</span>
dbms.security.<span class="hljs-attr">allow_csv_import_from_file_urls=true</span>

<span class="hljs-comment">#Retention policy for transaction logs needed to perform recovery and backups. 执行恢复和备份所需的事务日志的保留策略</span>
<span class="hljs-comment">#dbms.tx_log.rotation.retention_policy=7 days</span>

<span class="hljs-comment">#Enable a remote shell server which Neo4j Shell clients can log in to. 启用Neo4j Shell客户端可以登录的远程shell服务器</span>
dbms.shell.<span class="hljs-attr">enabled=true</span>
<span class="hljs-comment">#The network interface IP the shell will listen on (use 0.0.0.0 for all interfaces).</span>
dbms.shell.<span class="hljs-attr">host=127.0.0.1</span>
<span class="hljs-comment">#The port the shell will listen on, default is 1337.</span>
dbms.shell.<span class="hljs-attr">port=1337</span>

<span class="hljs-comment">#Only allow read operations from this Neo4j instance. This mode still requires write access to the directory for lock purposes. 只允许从Neo4j实例读取操作。此模式仍然需要对目录的写访问以用于锁定目的。</span>
<span class="hljs-comment">#dbms.read_only=false</span>

<span class="hljs-comment">#Comma separated list of JAX-RS packages containing JAX-RS resources, one package name for each mountpoint. The listed package names will be loaded under the mountpoints specified. Uncomment this line to mount the org.neo4j.examples.server.unmanaged.HelloWorldResource.java from neo4j-server-examples under /examples/unmanaged, resulting in a final URL of http://localhost:7474/examples/unmanaged/helloworld/&#123;nodeId&#125; 包含JAX-RS资源的JAX-RS软件包的逗号分隔列表，每个安装点一个软件包名称。所列出的软件包名称将在指定的安装点下加载。取消注释此行以装载org.neo4j.examples.server.unmanaged.HelloWorldResource.java neo4j-server-examples下/ examples / unmanaged，最终的URL为http//localhost7474/examples/unmanaged/helloworld/&#123;nodeId&#125;</span>
<span class="hljs-comment">#dbms.unmanaged_extension_classes=org.neo4j.examples.server.unmanaged=/examples/unmanaged</span>

<span class="hljs-comment">#JVM Parameters JVM参数</span>

<span class="hljs-comment">#G1GC generally strikes a good balance between throughput and tail latency, without too much tuning. G1GC通常在吞吐量和尾部延迟之间达到很好的平衡，而没有太多的调整。</span>
dbms.jvm.<span class="hljs-attr">additional=-XX:+UseG1GC</span>

<span class="hljs-comment">#Have common exceptions keep producing stack traces, so they can be debugged regardless of how often logs are rotated. 有共同的异常保持生成堆栈跟踪，所以他们可以被调试，无论日志被旋转的频率</span>
dbms.jvm.<span class="hljs-attr">additional=-XX:-OmitStackTraceInFastThrow</span>

<span class="hljs-comment">#Make sure that `initmemory` is not only allocated, but committed to the process, before starting the database. This reduces memory fragmentation, increasing the effectiveness of transparent huge pages. It also reduces the possibility of seeing performance drop due to heap-growing GC events, where a decrease in available page cache leads to an increase in mean IO response time. Try reducing the heap memory, if this flag degrades performance. 确保在启动数据库之前，“initmemory”不仅被分配，而且被提交到进程。这减少了内存碎片，增加了透明大页面的有效性。它还减少了由于堆增长的GC事件而导致性能下降的可能性，其中可用页面缓存的减少导致平均IO响应时间的增加。如果此标志降低性能，请减少堆内存。</span>
dbms.jvm.<span class="hljs-attr">additional=-XX:+AlwaysPreTouch</span>

<span class="hljs-comment">#Trust that non-static final fields are really final. This allows more optimizations and improves overall performance. <span class="hljs-doctag">NOTE:</span> Disable this if you use embedded mode, or have extensions or dependencies that may use reflection or serialization to change the value of final fields! 信任非静态final字段真的是final。这允许更多的优化和提高整体性能。注意：如果使用嵌入模式，或者有可能使用反射或序列化更改最终字段的值的扩展或依赖关系，请禁用此选项！</span>
dbms.jvm.<span class="hljs-attr">additional=-XX:+UnlockExperimentalVMOptions</span>
dbms.jvm.<span class="hljs-attr">additional=-XX:+TrustFinalNonStaticFields</span>

<span class="hljs-comment">#Disable explicit garbage collection, which is occasionally invoked by the JDK itself. 禁用显式垃圾回收，这是偶尔由JDK本身调用。</span>
dbms.jvm.<span class="hljs-attr">additional=-XX:+DisableExplicitGC</span>

<span class="hljs-comment">#Remote JMX monitoring, uncomment and adjust the following lines as needed. Absolute paths to jmx.access and jmx.password files are required. 远程JMX监视，取消注释并根据需要调整以下行。需要jmx.access和jmx.password文件的绝对路径。</span>
<span class="hljs-comment">#Also make sure to update the jmx.access and jmx.password files with appropriate permission roles and passwords, the shipped configuration contains only a read only role called ‘monitor’ with password ‘Neo4j’. 还要确保使用适当的权限角色和密码更新jmx.access和jmx.password文件，所配置的配置只包含名为“monitor”的只读角色，密码为“Neo4j”。</span>
<span class="hljs-comment">#For more details, see: http://download.oracle.com/javase/8/docs/technotes/guides/management/agent.html On Unix based systems the jmx.password file needs to be owned by the user that will run the server, and have permissions set to 0600. Unix系统，有关详情，请参阅：http：[//download.oracle.com/javase/8/docs/technotes/guides/management/agent.html，jmx.password文件需要由运行服务器的用户拥有，并且权限设置为0600。](https://download.oracle.com/javase/8/docs/technotes/guides/management/agent.html，jmx.password文件需要由运行服务器的用户拥有，并且权限设置为0600。)</span>
<span class="hljs-comment">#For details on setting these file permissions on Windows see: http://docs.oracle.com/javase/8/docs/technotes/guides/management/security-windows.html Windows系统 有关在设置这些文件权限的详细信息，请参阅：http://docs.oracle.com/javase/8/docs/technotes/guides/management/security-windows.html</span>
<span class="hljs-comment">#dbms.jvm.additional=-Dcom.sun.management.jmxremote.port=3637</span>
<span class="hljs-comment">#dbms.jvm.additional=-Dcom.sun.management.jmxremote.authenticate=true</span>
<span class="hljs-comment">#dbms.jvm.additional=-Dcom.sun.management.jmxremote.ssl=false</span>
<span class="hljs-comment">#dbms.jvm.additional=-Dcom.sun.management.jmxremote.password.file=/absolute/path/to/conf/jmx.password</span>
<span class="hljs-comment">#dbms.jvm.additional=-Dcom.sun.management.jmxremote.access.file=/absolute/path/to/conf/jmx.access</span>

<span class="hljs-comment">#Some systems cannot discover host name automatically, and need this line configured: 某些系统无法自动发现主机名，需要配置以下行：</span>
<span class="hljs-comment">#dbms.jvm.additional=-Djava.rmi.server.hostname=$THE_NEO4J_SERVER_HOSTNAME</span>

<span class="hljs-comment">#Expand Diffie Hellman (DH) key size from default 1024 to 2048 for DH-RSA cipher suites used in server TLS handshakes. 对于服务器TLS握手中使用的DH-RSA密码套件，将Diffie Hellman（DH）密钥大小从默认1024展开到2048。</span>
<span class="hljs-comment">#This is to protect the server from any potential passive eavesdropping. 这是为了保护服务器免受任何潜在的被动窃听。</span>
dbms.jvm.<span class="hljs-attr">additional=-Djdk.tls.ephemeralDHKeySize=2048</span>

<span class="hljs-comment">### Wrapper Windows NT/2000/XP Service Properties 包装器Windows NT / 2000 / XP服务属性包装器Windows NT / 2000 / XP服务属性</span>

<span class="hljs-comment">#WARNING - Do not modify any of these properties when an application using this configuration file has been installed as a service. WARNING - 当使用此配置文件的应用程序已作为服务安装时，不要修改任何这些属性。</span>
<span class="hljs-comment">#Please uninstall the service before modifying this section. The service can then be reinstalled. 请在修改此部分之前卸载服务。 然后可以重新安装该服务。</span>

<span class="hljs-comment">#Name of the service 服务的名称</span>
dbms.<span class="hljs-attr">windows_service_name=neo4j</span></code></pre>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Neo4j/">Neo4j</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="github.com/jing-yue" target="_blank" rel="nofollow noopener">
        <span>景岳</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Neo4j 学习&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
